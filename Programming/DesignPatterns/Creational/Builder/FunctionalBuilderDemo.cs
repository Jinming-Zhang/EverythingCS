using System;
using System.Collections.Generic;
using System.Linq;
/// <summary>
/// In a functional builder, we will create a buider class to build the object.
/// In the class we will keep a list of functions/delegates that will be applied to build the object. Think of this list of functions as list of building methods.
/// The builder will allow users to register additional functions to its list of functions.
/// Upon build, the builder will apply all functions in its stored list and apply them to a newly created emtpy object. The finsihed object will be returned.
/// To chaining the builder methods, we'll just return the Builder for each builder method.
/// To extend the bulder, we use extended methods, so that we are adhereing to the open/close principle, also without the need of inheritance.
/// </summary>
namespace FunctionalBuilderDemo
{
    public class Person
    {
        public string name, position;
        public override string ToString()
        {
            return $"I'm {name}, I work as a {position}.";
        }
    }
    /// <summary>
    /// Class the build the person object
    /// This class is sealed so other builder classes cannot inherit from this builder. However, the builder mehtods can be chained through extension methods without modifying this root builder class.
    /// The sealed class is to just to show that we can also adhere the open/close principle without using inheritance.
    /// </summary>
    public sealed class PersonBuilder
    {
        // This is a private fields that contains a list of functions (delegate), each function is of type : Takes a Person object as parameter and return a Person object. 
        private readonly List<Func<Person, Person>> builderMethods = new List<Func<Person, Person>>();

        public PersonBuilder Called(string name)
        {
            return EnqueueBuilderMethod(person => person.name = name);
        }

        // Since AddAction function is private, we use public Do fucntion as a wrapper which allows others to add actions
        public PersonBuilder EnqueueBuilderMethod(Action<Person> action)
        {
            return AddBuilderMethod(action);
        }

        public Person Build()
        {
            // Aggregate is similar to 'fold' or 'reduce' fuction in functional programming languages.
            // Here we created a new person as accumulator, and apply all the functions that are stored in our 'actions' list.
            // Finally we return the result Person as we finished the building process.
            return builderMethods.Aggregate(new Person(), (person, function) => function(person));
        }
        // We can add actions to this builder class
        private PersonBuilder AddBuilderMethod(Action<Person> builderMethod)
        {
            // here 'action' is a function that takes a Person object as parameter
            // To add the function into the 'actions' list, we turn it into an anonymous function, which takes a person as parameter, apply that to the 'action' function, and return the result person 
            builderMethods.Add((person) =>
            {
                builderMethod(person);
                return person;
            });

            return this;
        }
    }
    /// <summary>
    /// Here we'll show how to extends the builder using extension methods while adhere to the open/close principle
    /// </summary>
    public static class PersonBuilderExtensions
    {
        // %%%%%%%%%%%%%%%%%%%%%%%%%% Note on Extension Methods %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        // This is an extension mehtod, note from MS docs for extension methods...
        // "Extension methods are static methods, but they're called as if they were instance methods on the extended type"
        // Extension methods are defined as static methods but are called by using instance method syntax
        // Their first parameter specifies which type/Class the method operates on. The parameter is preceded by the this modifier. Extension methods are only in scope when you explicitly import the namespace into your source code with a using directive.
        // The intermediate language (IL) generated by the compiler translates your code into a call on the static method. The principle of encapsulation is not really being violated. Extension methods cannot access private variables in the type they are extending.
        // for more info on Extension methods:
        // https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods
        // %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
        public static PersonBuilder WorksAs(this PersonBuilder builder, string position)
        {
            return builder.EnqueueBuilderMethod((person) =>
             {
                 person.position = position;
             });
        }
    }
    public class FunctionalBuilderDemo
    {
        public void Demo()
        {
            PersonBuilder personBuilder = new PersonBuilder();
            // Note that here each time we call the builder method (Called, WorkAs), the builder actually add the function to its builder functons list, and return the Builder object at the same time so we can chain other builders.
            // Also the object is not being built at all until the Build() function is called.
            Person newPerson = personBuilder.Called("Wolf").WorksAs("Eater").Build();
            Console.WriteLine(newPerson);
        }
    }
}